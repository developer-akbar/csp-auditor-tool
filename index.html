<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSP Auditor - Content Security Policy Analysis Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .input-section {
            margin-bottom: 40px;
        }

        .input-group {
            margin-bottom: 25px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.1rem;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            font-family: inherit;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .input-group textarea {
            min-height: 120px;
            resize: vertical;
        }

        .input-group small {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 0.9rem;
        }

        .cors-info {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .cors-info h4 {
            color: #1976d2;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .cors-info p {
            margin-bottom: 10px;
            color: #1565c0;
            font-size: 0.95rem;
        }

        .cors-info ul {
            margin: 10px 0 15px 20px;
            color: #1565c0;
        }

        .cors-info li {
            margin-bottom: 5px;
        }

        .process-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-weight: 600;
            width: 100%;
            margin-bottom: 30px;
        }

        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .process-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-section {
            display: none;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e8ed;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status-text {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .progress-details {
            color: #666;
            font-size: 0.9rem;
        }

        .results-section {
            display: none;
            margin-bottom: 40px;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e1e8ed;
        }

        .results-header h3 {
            color: #2c3e50;
            font-size: 1.5rem;
        }

        .download-buttons {
            display: flex;
            gap: 10px;
        }

        .download-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            text-decoration: none;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }

        .download-btn:hover {
            background: #229954;
        }

        .download-btn.secondary {
            background: #3498db;
        }

        .download-btn.secondary:hover {
            background: #2980b9;
        }

        .summary-report {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .summary-report h4 {
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .directive-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .directive-item {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .directive-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .directive-count {
            color: #667eea;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .cdn-comparison {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .cdn-comparison h4 {
            color: #856404;
            margin-bottom: 15px;
        }

        .missing-directives {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }

        .missing-directives h5 {
            color: #721c24;
            margin-bottom: 10px;
        }

        .missing-list {
            list-style: none;
            color: #721c24;
        }

        .missing-list li {
            margin-bottom: 5px;
            padding: 5px 10px;
            background: rgba(220, 53, 69, 0.1);
            border-radius: 4px;
        }

        .updated-rule {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }

        .updated-rule h5 {
            color: #155724;
            margin-bottom: 10px;
        }

        .rule-text {
            background: white;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            margin-bottom: 15px;
        }

        .copy-btn {
            background: #6c5ce7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }

        .copy-btn:hover {
            background: #5f3dc4;
        }

        .copy-btn.copied {
            background: #00b894;
        }

        .error-message {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            color: #721c24;
            display: none;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .download-buttons {
                flex-direction: column;
            }
            
            .directive-stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîí CSP Auditor</h1>
            <p>Content Security Policy Analysis & CDN Configuration Tool</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <div class="input-group">
                    <label for="sitemap-url">üåê Sitemap URL</label>
                    <input type="url" id="sitemap-url" placeholder="https://example.com/sitemap.xml">
                    <small>Enter your website's sitemap XML URL to automatically extract all page URLs</small>
                </div>

                <div class="input-group">
                    <label for="manual-urls">üìù Manual URLs (Alternative)</label>
                    <textarea id="manual-urls" placeholder="https://example.com/page1&#10;https://example.com/page2&#10;https://example.com/page3"></textarea>
                    <small>Enter URLs manually, one per line or comma-separated (if not using sitemap)</small>
                </div>

                <div class="cors-info">
                    <h4>üîí CORS & Access Information</h4>
                    <p><strong>Note:</strong> This tool automatically handles CORS restrictions using multiple strategies:</p>
                    <ul>
                        <li>Direct fetch (when possible)</li>
                        <li>Multiple CORS proxy services as fallbacks</li>
                        <li>Automatic strategy switching on failures</li>
                    </ul>
                    <p><strong>For best results:</strong> Use URLs from your own domain or public websites. The tool will automatically find the best way to access each URL.</p>
                    <p><strong>Browser Extensions:</strong> For persistent CORS issues, consider installing extensions like "CORS Unblock" or "Allow CORS" for development purposes.</p>
                </div>

                <button id="process-btn" class="process-btn">
                    <span class="spinner hidden"></span>
                    Extract CSP Directives
                </button>
            </div>

            <div id="progress-section" class="progress-section">
                <div class="status-text" id="status-text">Processing...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-details" id="progress-details">Initializing...</div>
            </div>

            <div id="error-message" class="error-message"></div>

            <div id="results-section" class="results-section">
                <div class="results-header">
                    <h3>üìä Analysis Results</h3>
                    <div class="download-buttons">
                        <a id="csv-download" class="download-btn" href="#" download>üì• Download CSV</a>
                        <a id="json-download" class="download-btn secondary" href="#" download>üì• Download JSON</a>
                    </div>
                </div>

                <div class="summary-report">
                    <h4>üìã Summary Report</h4>
                    <div class="directive-stats" id="directive-stats"></div>
                </div>

                <div class="cdn-comparison">
                    <h4>üîç CDN Rule Comparison</h4>
                    <div class="input-group">
                        <label for="existing-cdn-rule">Existing CDN CSP Rule:</label>
                        <textarea id="existing-cdn-rule" placeholder="script-src 'self' 'unsafe-inline' https://cdn.example.com;"></textarea>
                        <small>Paste your current CDN CSP configuration to compare with extracted directives</small>
                    </div>
                    <button id="compare-btn" class="process-btn" style="width: auto; margin: 0;">Compare & Generate Updated Rule</button>
                    
                    <div id="missing-directives" class="missing-directives hidden">
                        <h5>‚ö†Ô∏è Missing Directives</h5>
                        <ul class="missing-list" id="missing-list"></ul>
                    </div>
                    
                    <div id="updated-rule" class="updated-rule hidden">
                        <h5>‚úÖ Updated CDN Rule</h5>
                        <div class="rule-text" id="rule-text"></div>
                        <button id="copy-rule-btn" class="copy-btn">üìã Copy Updated Rule</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class CSPAuditor {
            constructor() {
                this.urls = [];
                this.results = [];
                this.currentIndex = 0;
                this.totalUrls = 0;
                this.startTime = 0;
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('process-btn').addEventListener('click', () => this.startProcessing());
                document.getElementById('compare-btn').addEventListener('click', () => this.compareCDNRules());
                document.getElementById('copy-rule-btn').addEventListener('click', () => this.copyToClipboard());
            }

            async startProcessing() {
                const sitemapUrl = document.getElementById('sitemap-url').value.trim();
                const manualUrls = document.getElementById('manual-urls').value.trim();

                if (!sitemapUrl && !manualUrls) {
                    this.showError('Please provide either a sitemap URL or manual URLs.');
                    return;
                }

                try {
                    this.showProgress();
                    this.results = [];
                    this.currentIndex = 0;
                    this.startTime = Date.now();

                    if (sitemapUrl) {
                        await this.processSitemap(sitemapUrl);
                    } else {
                        this.urls = this.parseManualUrls(manualUrls);
                    }

                    this.totalUrls = this.urls.length;
                    if (this.totalUrls === 0) {
                        this.showError('No valid URLs found to process.');
                        return;
                    }

                    await this.processUrls();
                    this.displayResults();
                    this.hideProgress();
                } catch (error) {
                    this.showError(`Error: ${error.message}`);
                    this.hideProgress();
                }
            }

            async processSitemap(sitemapUrl) {
                try {
                    const response = await fetch(sitemapUrl);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch sitemap: ${response.status}`);
                    }
                    
                    const xmlText = await response.text();
                    this.urls = this.extractUrlsFromSitemap(xmlText);
                } catch (error) {
                    throw new Error(`Sitemap processing failed: ${error.message}`);
                }
            }

            extractUrlsFromSitemap(xmlText) {
                const urlRegex = /<loc>(.*?)<\/loc>/g;
                const urls = [];
                let match;
                
                while ((match = urlRegex.exec(xmlText)) !== null) {
                    const url = match[1].trim();
                    if (url && this.isValidUrl(url)) {
                        urls.push(url);
                    }
                }
                
                return urls;
            }

            parseManualUrls(urlsText) {
                return urlsText
                    .split(/[,\n]/)
                    .map(url => url.trim())
                    .filter(url => url && this.isValidUrl(url));
            }

            isValidUrl(string) {
                try {
                    new URL(string);
                    return true;
                } catch (_) {
                    return false;
                }
            }

            async processUrls() {
                for (let i = 0; i < this.urls.length; i++) {
                    this.currentIndex = i + 1;
                    this.updateProgress();
                    
                    try {
                        const result = await this.analyzePage(this.urls[i]);
                        this.results.push(result);
                    } catch (error) {
                        console.warn(`Failed to analyze ${this.urls[i]}:`, error);
                        this.results.push({
                            url: this.urls[i],
                            error: error.message,
                            csp: null
                        });
                    }
                }
            }

            async analyzePage(url) {
                try {
                    // Try multiple fetch strategies to handle CORS
                    const result = await this.fetchWithFallbacks(url);
                    return result;
                } catch (error) {
                    throw new Error(`Failed to fetch: ${error.message}`);
                }
            }

            async fetchWithFallbacks(url) {
                const strategies = [
                    { name: 'Direct Fetch', fn: () => this.fetchDirect(url) },
                    { name: 'CORS Anywhere Proxy', fn: () => this.fetchWithProxy(url, 'https://cors-anywhere.herokuapp.com/') },
                    { name: 'AllOrigins Proxy', fn: () => this.fetchWithProxy(url, 'https://api.allorigins.win/raw?url=') },
                    { name: 'CORS Bridge', fn: () => this.fetchWithProxy(url, 'https://cors.bridged.cc/') },
                    { name: 'ThingProxy', fn: () => this.fetchWithProxy(url, 'https://thingproxy.freeboard.io/fetch/') }
                ];

                for (let i = 0; i < strategies.length; i++) {
                    try {
                        this.updateCORSStrategy(strategies[i].name, url);
                        const result = await strategies[i].fn();
                        if (result) {
                            console.log(`Strategy ${i + 1} (${strategies[i].name}) succeeded for ${url}`);
                            return result;
                        }
                    } catch (error) {
                        console.warn(`Strategy ${i + 1} (${strategies[i].name}) failed for ${url}:`, error.message);
                        continue;
                    }
                }

                throw new Error('All fetch strategies failed due to CORS restrictions');
            }

            async fetchDirect(url) {
                try {
                    // First try HEAD request for CSP headers
                    const headResponse = await fetch(url, {
                        method: 'HEAD',
                        mode: 'cors',
                        credentials: 'omit'
                    });

                    if (headResponse.ok) {
                        const csp = headResponse.headers.get('content-security-policy');
                        if (csp) {
                            return {
                                url: url,
                                csp: csp,
                                source: 'header'
                            };
                        }
                    }

                    // If no CSP in headers, try GET request for meta tags
                    const htmlResponse = await fetch(url, {
                        method: 'GET',
                        mode: 'cors',
                        credentials: 'omit'
                    });

                    if (htmlResponse.ok) {
                        const html = await htmlResponse.text();
                        const metaCSP = this.extractCSPFromMeta(html);
                        return {
                            url: url,
                            csp: metaCSP || 'No CSP found',
                            source: metaCSP ? 'meta tag' : 'none'
                        };
                    }

                    return null;
                } catch (error) {
                    throw error;
                }
            }

            async fetchWithProxy(url, proxyUrl) {
                try {
                    const fullUrl = proxyUrl + encodeURIComponent(url);
                    const response = await fetch(fullUrl, {
                        method: 'GET',
                        credentials: 'omit',
                        headers: {
                            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Proxy request failed: ${response.status}`);
                    }

                    const html = await response.text();
                    const metaCSP = this.extractCSPFromMeta(html);
                    
                    return {
                        url: url,
                        csp: metaCSP || 'No CSP found',
                        source: metaCSP ? 'meta tag (via proxy)' : 'none (via proxy)'
                    };
                } catch (error) {
                    throw error;
                }
            }

            extractCSPFromMeta(html) {
                const metaRegex = /<meta[^>]*http-equiv=["']Content-Security-Policy["'][^>]*content=["']([^"']+)["'][^>]*>/i;
                const match = html.match(metaRegex);
                return match ? match[1] : null;
            }

            updateProgress() {
                const progress = (this.currentIndex / this.totalUrls) * 100;
                document.getElementById('progress-fill').style.width = `${progress}%`;
                
                const elapsed = Date.now() - this.startTime;
                const avgTimePerUrl = elapsed / this.currentIndex;
                const remainingUrls = this.totalUrls - this.currentIndex;
                const estimatedTime = Math.round((avgTimePerUrl * remainingUrls) / 1000);
                
                document.getElementById('status-text').textContent = `Processing URL ${this.currentIndex} of ${this.totalUrls}`;
                document.getElementById('progress-details').textContent = 
                    `Estimated time remaining: ${estimatedTime} seconds`;
            }

            updateCORSStrategy(strategyName, url) {
                const progressDetails = document.getElementById('progress-details');
                const currentText = progressDetails.textContent;
                progressDetails.textContent = `${currentText} | Trying: ${strategyName}`;
            }

            displayResults() {
                const directiveStats = this.analyzeDirectives();
                this.displayDirectiveStats(directiveStats);
                this.generateDownloadFiles();
                this.showResults();
            }

            analyzeDirectives() {
                const stats = {};
                const allDirectives = new Set();

                this.results.forEach(result => {
                    if (result.csp && result.csp !== 'No CSP found') {
                        const directives = this.parseCSPDirectives(result.csp);
                        directives.forEach(directive => {
                            allDirectives.add(directive.name);
                            if (!stats[directive.name]) {
                                stats[directive.name] = {
                                    count: 0,
                                    values: new Set()
                                };
                            }
                            stats[directive.name].count++;
                            directive.values.forEach(value => stats[directive.name].values.add(value));
                        });
                    }
                });

                return { stats, allDirectives };
            }

            parseCSPDirectives(cspString) {
                const directives = [];
                const directiveRegex = /([^;]+)/g;
                let match;

                while ((match = directiveRegex.exec(cspString)) !== null) {
                    const directive = match[1].trim();
                    const spaceIndex = directive.indexOf(' ');
                    
                    if (spaceIndex > 0) {
                        const name = directive.substring(0, spaceIndex).trim();
                        const values = directive.substring(spaceIndex + 1).trim().split(/\s+/);
                        
                        directives.push({
                            name: name,
                            values: values
                        });
                    }
                }

                return directives;
            }

            displayDirectiveStats(analysis) {
                const container = document.getElementById('directive-stats');
                container.innerHTML = '';

                Object.entries(analysis.stats).forEach(([directive, data]) => {
                    const item = document.createElement('div');
                    item.className = 'directive-item';
                    item.innerHTML = `
                        <div class="directive-name">${directive}</div>
                        <div class="directive-count">${data.count} pages</div>
                        <small>${Array.from(data.values).slice(0, 3).join(', ')}${data.values.size > 3 ? '...' : ''}</small>
                    `;
                    container.appendChild(item);
                });
            }

            generateDownloadFiles() {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const domain = this.extractDomain(this.urls[0] || 'unknown');
                
                // Generate CSV
                const csvContent = this.generateCSV();
                const csvBlob = new Blob([csvContent], { type: 'text/csv' });
                const csvUrl = URL.createObjectURL(csvBlob);
                document.getElementById('csv-download').href = csvUrl;
                document.getElementById('csv-download').download = `csp-analysis-${domain}-${timestamp}.csv`;

                // Generate JSON
                const jsonContent = JSON.stringify({
                    metadata: {
                        timestamp: new Date().toISOString(),
                        totalUrls: this.totalUrls,
                        domain: domain
                    },
                    results: this.results
                }, null, 2);
                const jsonBlob = new Blob([jsonContent], { type: 'application/json' });
                const jsonUrl = URL.createObjectURL(jsonBlob);
                document.getElementById('json-download').href = jsonUrl;
                document.getElementById('json-download').download = `csp-analysis-${domain}-${timestamp}.json`;
            }

            generateCSV() {
                const headers = ['URL', 'CSP Source', 'Content Security Policy', 'Error'];
                const rows = [headers.join(',')];
                
                this.results.forEach(result => {
                    const row = [
                        result.url,
                        result.source || 'N/A',
                        result.csp || 'N/A',
                        result.error || 'N/A'
                    ].map(field => `"${field.replace(/"/g, '""')}"`).join(',');
                    rows.push(row);
                });
                
                return rows.join('\n');
            }

            extractDomain(url) {
                try {
                    return new URL(url).hostname;
                } catch {
                    return 'unknown';
                }
            }

            compareCDNRules() {
                const existingRule = document.getElementById('existing-cdn-rule').value.trim();
                if (!existingRule) {
                    this.showError('Please enter your existing CDN CSP rule first.');
                    return;
                }

                const missingDirectives = this.findMissingDirectives(existingRule);
                const updatedRule = this.generateUpdatedRule(existingRule, missingDirectives);
                
                this.displayComparisonResults(missingDirectives, updatedRule);
            }

            findMissingDirectives(existingRule) {
                const existingDirectives = this.parseCSPDirectives(existingRule);
                const existingNames = new Set(existingDirectives.map(d => d.name));
                const missing = [];

                this.results.forEach(result => {
                    if (result.csp && result.csp !== 'No CSP found') {
                        const pageDirectives = this.parseCSPDirectives(result.csp);
                        pageDirectives.forEach(directive => {
                            if (!existingNames.has(directive.name)) {
                                missing.push(directive);
                            }
                        });
                    }
                });

                return missing;
            }

            generateUpdatedRule(existingRule, missingDirectives) {
                const uniqueMissing = new Map();
                missingDirectives.forEach(directive => {
                    if (!uniqueMissing.has(directive.name)) {
                        uniqueMissing.set(directive.name, directive);
                    }
                });

                let updatedRule = existingRule;
                uniqueMissing.forEach(directive => {
                    const newDirective = `${directive.name} ${Array.from(directive.values).join(' ')};`;
                    updatedRule += ' ' + newDirective;
                });

                return updatedRule;
            }

            displayComparisonResults(missingDirectives, updatedRule) {
                const missingContainer = document.getElementById('missing-directives');
                const updatedContainer = document.getElementById('updated-rule');
                const missingList = document.getElementById('missing-list');
                const ruleText = document.getElementById('rule-text');

                if (missingDirectives.length > 0) {
                    missingList.innerHTML = '';
                    const uniqueMissing = new Map();
                    missingDirectives.forEach(directive => {
                        if (!uniqueMissing.has(directive.name)) {
                            uniqueMissing.set(directive.name, directive);
                        }
                    });

                    uniqueMissing.forEach(directive => {
                        const li = document.createElement('li');
                        li.textContent = `${directive.name}: ${Array.from(directive.values).join(' ')}`;
                        missingList.appendChild(li);
                    });

                    missingContainer.classList.remove('hidden');
                } else {
                    missingContainer.classList.add('hidden');
                }

                ruleText.textContent = updatedRule;
                updatedContainer.classList.remove('hidden');
            }

            async copyToClipboard() {
                const ruleText = document.getElementById('rule-text').textContent;
                try {
                    await navigator.clipboard.writeText(ruleText);
                    const btn = document.getElementById('copy-rule-btn');
                    btn.textContent = '‚úÖ Copied!';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = 'üìã Copy Updated Rule';
                        btn.classList.remove('copied');
                    }, 2000);
                } catch (error) {
                    this.showError('Failed to copy to clipboard. Please copy manually.');
                }
            }

            showProgress() {
                document.getElementById('progress-section').style.display = 'block';
                document.getElementById('process-btn').disabled = true;
                document.getElementById('process-btn').querySelector('.spinner').classList.remove('hidden');
                document.getElementById('error-message').style.display = 'none';
            }

            hideProgress() {
                document.getElementById('progress-section').style.display = 'none';
                document.getElementById('process-btn').disabled = false;
                document.getElementById('process-btn').querySelector('.spinner').classList.add('hidden');
            }

            showResults() {
                document.getElementById('results-section').style.display = 'block';
            }

            showError(message) {
                const errorElement = document.getElementById('error-message');
                
                // Enhanced error handling for CORS issues
                if (message.includes('CORS') || message.includes('Access-Control-Allow-Origin')) {
                    errorElement.innerHTML = `
                        <strong>CORS Access Issue Detected</strong><br>
                        ${message}<br><br>
                        <strong>Solutions:</strong><br>
                        ‚Ä¢ The tool is automatically trying multiple CORS proxy services<br>
                        ‚Ä¢ Try using URLs from your own domain first<br>
                        ‚Ä¢ Some websites may block all external access<br>
                        ‚Ä¢ Check browser console for detailed strategy attempts
                    `;
                } else {
                    errorElement.textContent = message;
                }
                
                errorElement.style.display = 'block';
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 8000);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new CSPAuditor();
        });
    </script>
</body>
</html>
